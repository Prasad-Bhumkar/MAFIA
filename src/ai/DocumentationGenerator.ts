import * as vscode from 'vscode';
import * as path from 'path';
import { AIServiceV2 } from './AIServiceV2';
import { FileParserUtils } from '../utils/FileParserUtils';
import { ErrorHandler } from '../utils/ErrorHandler';
import { DocumentationExporter } from '../export/DocumentationExporter';

export class DocumentationGenerator {
    private static instance: DocumentationGenerator;
    private aiService: AIServiceV2;
    private parser: FileParserUtils;

    public constructor(context: vscode.ExtensionContext) {
        this.aiService = AIServiceV2.getInstance(context);
        this.parser = new FileParserUtils();
    }

    public static getInstance(context: vscode.ExtensionContext): DocumentationGenerator {
        if (!DocumentationGenerator.instance) {
            DocumentationGenerator.instance = new DocumentationGenerator(context);
        }
        return DocumentationGenerator.instance;
    }

    public async generateDocumentation(document: vscode.TextDocument): Promise<string> {
        try {
            // Parse code structure and extract existing docs
            const codeStructure = await this.parser.parseDocument(document);
            
            // Generate documentation for undocumented sections
            const aiResponse = await this.aiService.getEnhancedSuggestions({
                context: codeStructure,
                language: this.getLanguageId(document.languageId),
                cursorPosition: new vscode.Position(0, 0),
                document,
                prompt: 'Generate comprehensive documentation for this code'
            });

            return this.formatDocumentation(aiResponse.suggestions[0], codeStructure);
        } catch (error) {
            ErrorHandler.handle(error, 'Documentation Generation');
            throw error;
        }
    }

    private getLanguageId(vscodeLanguageId: string): 'java' | 'typescript' | 'python' | 'go' | 'rust' {
        const mapping: Record<string, any> = {
            'java': 'java',
            'typescript': 'typescript',
            'javascript': 'typescript',
            'python': 'python',
            'go': 'go',
            'rust': 'rust'
        };
        return mapping[vscodeLanguageId] || 'typescript';
    }

    private formatDocumentation(aiContent: string, codeStructure: string): string {
        const timestamp = new Date().toISOString();
        return `# Code Documentation\n\n` +
               `## Structure Overview\n${codeStructure}\n\n` +
               `## AI-Generated Documentation\n${aiContent}\n\n` +
               `---\n` +
               `*Documentation generated by MAFIA on ${timestamp}*\n` +
               `*This is an AI-generated documentation. Please review for accuracy.*`;
    }

    public async exportDocumentation(
        document: vscode.TextDocument,
        exporter: DocumentationExporter
    ): Promise<void> {
        try {
            const docContent = await this.generateDocumentation(document);
            const fileName = `${path.basename(document.fileName, path.extname(document.fileName))}_docs.md`;
            
            const choice = await vscode.window.showQuickPick(
                ['Save to file', 'Copy to clipboard', 'Preview'],
                { placeHolder: 'How would you like to export the documentation?' }
            );

            if (choice === 'Save to file') {
                await exporter.exportToFile(docContent, fileName);
            } else if (choice === 'Copy to clipboard') {
                await exporter.exportToClipboard(docContent);
            } else if (choice === 'Preview') {
                const panel = vscode.window.createWebviewPanel(
                    'documentationPreview',
                    'Documentation Preview',
                    vscode.ViewColumn.Beside,
                    {}
                );
                panel.webview.html = this.getPreviewHtml(docContent);
            }
        } catch (error) {
            ErrorHandler.handle(error, 'Documentation Export');
            throw error;
        }
    }

    private getPreviewHtml(content: string): string {
        const marked = require('marked');
        return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Documentation Preview</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        pre { background: #f5f5f5; padding: 10px; border-radius: 3px; }
        code { font-family: Consolas, monospace; }
    </style>
</head>
<body>
${marked.parse(content)}
</body>
</html>`;
    }
}